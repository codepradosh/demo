#!/usr/bin/env python3
"""
RAW CSV Cleaner - Checks opened_at column for valid datetime
Removes rows where opened_at is blank or not a datetime
"""

import sys
import re

if len(sys.argv) < 3:
    print("Usage: python clean_raw.py input.csv output.csv")
    sys.exit(1)

input_file = sys.argv[1]
output_file = sys.argv[2]

print("=" * 60)
print("ğŸ§¹ RAW CSV CLEANER (Check opened_at datetime)")
print("=" * 60)
print(f"Input:  {input_file}")
print(f"Output: {output_file}")

# Datetime pattern to match:
# 2025-02-22 22:32:11+00:00
# 2025-02-22T22:32:11.001+0000
# Must start with YYYY-MM-DD
datetime_pattern = re.compile(r'^\d{4}-\d{2}-\d{2}')

def is_valid_datetime(value):
    """Check if value looks like a datetime (starts with YYYY-MM-DD)"""
    if not value or value.strip() == '':
        return False
    return bool(datetime_pattern.match(value.strip()))

# Read as raw text
print("\nğŸ“– Reading file as raw text...")
with open(input_file, 'r', encoding='utf-8', errors='replace') as f:
    lines = f.readlines()

total_lines = len(lines)
print(f"   Total lines: {total_lines:,}")

# Parse header to find opened_at column index
header = lines[0]
header_fields = header.strip().split(',')
print(f"\nğŸ” Header columns: {len(header_fields)}")

# Find opened_at column
opened_at_idx = None
for i, col in enumerate(header_fields):
    if 'opened_at' in col.lower():
        opened_at_idx = i
        print(f"   Found 'opened_at' at column index {i} (column name: '{col}')")
        break

if opened_at_idx is None:
    print("âŒ ERROR: 'opened_at' column not found in header!")
    print(f"   First 10 columns: {header_fields[:10]}")
    sys.exit(1)

# Show sample lines
print("\nğŸ” First 5 data lines (opened_at values):")
for i, line in enumerate(lines[1:6], start=1):
    fields = line.strip().split(',')
    if len(fields) > opened_at_idx:
        val = fields[opened_at_idx]
        valid = "âœ…" if is_valid_datetime(val) else "âŒ"
        print(f"   Line {i}: opened_at = '{val[:40]}' {valid}")

print("\nğŸ” Last 5 data lines (opened_at values):")
for i, line in enumerate(lines[-5:], start=total_lines-5):
    fields = line.strip().split(',')
    if len(fields) > opened_at_idx:
        val = fields[opened_at_idx]
        valid = "âœ…" if is_valid_datetime(val) else "âŒ"
        print(f"   Line {i}: opened_at = '{val[:40]}' {valid}")

# Filter: Keep only lines where opened_at is a valid datetime
print("\nğŸ” Filtering lines based on opened_at column...")

valid_lines = [header]  # Keep header
invalid_count = 0
invalid_examples = []

for i, line in enumerate(lines[1:], start=1):
    fields = line.strip().split(',')
    
    # Get opened_at value
    if len(fields) > opened_at_idx:
        opened_at_value = fields[opened_at_idx].strip()
        
        if is_valid_datetime(opened_at_value):
            valid_lines.append(line)
        else:
            invalid_count += 1
            if len(invalid_examples) < 20:
                # Also get incident_number for reference (assume it's column 0)
                inc_num = fields[0][:30] if len(fields) > 0 else "N/A"
                invalid_examples.append(f"Line {i}: incident='{inc_num}', opened_at='{opened_at_value[:30]}'")
    else:
        # Row has fewer columns than expected
        invalid_count += 1
        if len(invalid_examples) < 20:
            invalid_examples.append(f"Line {i}: <missing columns>")

print(f"\nâŒ Found {invalid_count:,} INVALID lines (missing/invalid datetime)")
if invalid_examples:
    print("   Examples:")
    for ex in invalid_examples:
        print(f"      {ex}")

print(f"\nâœ… Valid lines: {len(valid_lines):,} (including header)")

# Write output
print(f"\nğŸ’¾ Saving to {output_file}...")
with open(output_file, 'w', encoding='utf-8') as f:
    f.writelines(valid_lines)

print("\n" + "=" * 60)
print("ğŸ“Š SUMMARY")
print("=" * 60)
print(f"   Original lines: {total_lines:,}")
print(f"   Invalid removed: {invalid_count:,}")
print(f"   Final lines: {len(valid_lines):,}")
print("âœ… DONE!")
